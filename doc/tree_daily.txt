// tree_daily.txt
// hyan23 编辑。
//

2016.04.29
1. 例程: put_char, ASCLL_LF, ASCLL_CR。

2016.04.30
1. 例程: put_string, 转义: '\n', '\\'。
2. 例程: clrscr, gotoxy, ...。
3. 编写自己的fixvhdwr工具。

2016.05.01
1. 使用Makefile构建工程。
2. 使用BOCHS调试程序。
3. 例程: read_sector, 加载扩展的MBR: mbrx。

2016.05.02
1. 新增并配置GCC套件。(没有用上)
2. 试验GCC和nasm联合编译。
3. 整理/调整项目文件夹。
4. 理解nasm的[bits n]语法。
5. 完善MBRX的加载算法。

2016.05.03
1. 例程: get_time, put_bcd。

2016.05.04
1. 系统时钟更新中断服务程序。
2. 修复: read_block, 扇区数量。

2016.05.05
1. 考虑应用程序动态链接, 和加载。
2. 规划[TREE]二进制文件结构。

2016.05.06
1. 文件结构设计好了, 基本包含动态加载链接所需信息。
2. 编写创建这个结构的宏, 导入, 导出符号的宏。

2016.05.07
1. 规划内核内存布局。
2. 继续考虑程序动态加载。

2016.05.08
1. 考虑系统基础运行时的加载, 例如链接器, 打印相关的...
2. 加载完成后, 链接系统核心符号, 完成系统自举。

2016.05.09
1. 编写加载器, 完成70%。

2016.05.10
1. 编写加载器, 完成71%。

2016.05.11
1. 编写加载器, 完成100%。
2. 计划:
下一步: 链接器, shell。
下二步: 开启保护模式, 开启分页。
下三步: 文件系统。
下四步: 多任务, 图形用户界面。
下五步: 还没想好。

2016.05.12
1. 链接器, 90%(没有调试)。

2016.05.13
1. 链接器调试得差不多了。
2. 开始写执行器。

2016.05.14
1. 什么也没写。

2016.05.15
1. 写了一点点。

2016.05.16
1. 写了一点点。
2. 完成[TREE]执行程序(没有调试)。

2016.05.17
1. [TREE]执行程序(调试好)。
2. 增加结束程序系统调用。

2016.05.18
1. 搞忘做了什么。

2016.05.19
1. 实现程序动态加载, 链接(调试以前写的绝大部分例程)。
2. 安装基于该体制下的时钟中断。
3. 明天编写键盘中断处理程序。

2016.05.20
1. 标准化。

2016.05.21
1. 标准化(完成)。

2016.05.22
1. 修改进程表, 符号表, 新增pid属性。

2016.05.23 - 2016.05.24
1. 考虑进程的卸载, 进程依赖。

2016.05.25
1. 完成[TREE]执行环境。
2. 设计[TREE]-NASM编码规范。

2016.05.26
1. 完成kbd库, 简单实现。
2. 明天做sh, 是托管所有输入输出。(不是)

2016.05.27
1. 完善kbd库, 重新规划内存布局。
2. 新增完成系统调用的宏。

2016.05.28
1. 完成kbd, 可处理capslock, 和shift了。
2. 有一个bug, 开机时会丢失前两次键击。

2016.05.29
1. 完成一个小小的shell。
2. 昨天的bug还没有处理。;;;;

2016.05.30
1. 整理代码。

2016.05.31
1. 整理代码。
2. 开始使用visual-studio code。

2016.06.01
1. 整理代码。
2. 增加graphic库, 320*200*8bit图形支持, 增加颜色系统
(同时适用于控制台)。

2016.06.02
1. 新增graphic/printscr, graphic/drawline。
2. 准备把操作系统切换到32位保护模式。
3. 编写工具, gendes, 帮助可视化生成段描述符。

2016.06.03
1. 调整内存布局等问题。

2016.06.04 - 2016.06.05
1. ~

2016.06.06
1. 保护模式下的外部过程调用。
2. 复习调用门的知识和特权级控制。

2016.06.07
1. 调整架构, 先让系统在保护模式下运行起来,
再做其他事情。

2016.06.08
1. 实现保护模式下的动态内存分配(20%)。

2016.06.09
2. 实现保护模式下的动态内存分配(30%)。

2016.06.10
1. 实现保护模式下段式的动态内存分配(75%), 还没调试。

2016.06.11
1. 实现保护模式下段式的动态内存分配(100%)。

2016.06.12
1. 更新加载器(30%)。
2. 更新动态内存分配（75%), 小粒度, 还没调试。

2016.06.13
1. 更新的动态内存分配, 调试好。
2. 完成加载器重制。

2016.06.14
1. 更新链接器(45%)。

2016.06.15
1. 更新链接器和执行程序(75%)。

2016.06.16
1. 完成保护模式下执行环境。
2. 试验使用调用门和中断。

2016.06.17
1. 新增: 任务管理, 门管理, 中断管理, 特权代码调用(概念)。

2016.06.18 - 2016.06.20
1. ~

2016.06.21
1. 新增进程空间的概念，创建四套特权栈。

2016.06.22
1. 调试程序。

2016.06.23
1. 修复一个混淆符号名和文件名长度的问题。
2. 修复特权栈整体上浮覆盖代码的问题。
3. 安装并测试调用门，实现特权代码代理。

2016.06.24
1. 修复读磁盘数据块代码的一个错误。
2. 修复段式内存管理代码的一个错误。

2016.06.25
1. 创建一个任务。
2. 链接器还有问题。

2016.06.26
1. 整理代码。
2. 修复链接器(依赖项填写重叠)。
3. 修改外部调用逻辑, 现在支持嵌套外部调用了, 具体
参看tree/inc/tree.ic。
4. 特权级保护OK。
5. 复习任务切换的知识。
6. 明天修改: 取消使用加载描述符别名的方式访问调用门选择子表。

2016.06.27
1. 写了一点任务管理的代码。

2016.06.28
1. 我在扩展的引导代码尝试了一下分页, 发现在当前机制下, 要用页实现目前
已经实现的功能, 非常复杂, 也找不到相关资料，再加上这次
开发本着学习的目的, 因此决定不支持
分页内存管理, 直接跳过进入下一部分, 中断和多任务。
2. 实现了保护模式下的异常与中断处理。
3. 新增远调用静态数据访问功能, 这个也是以前没考虑到的。

2016.06.29
1. 考虑任务切换。
2. 调用门的安装还有点问题。

2016.06.30
1. 成功实现了任务切换。
2. 本地远调用宏在多任务下运行不是很好, 必须增加原子操作。
3. 使用使用调用门关中断方式实现原子操作。
4. 心得: 处理中断务必要保护好现场, 保护模式下从中断返回加载的
是tss中的段选择子, 如果要临时修改段寄存器一定要记住先关中断。

2016.07.01
1. 实现零级特权级代码接口, 取消使用描述符别名访问调用门选择子表。
2. 调整所有历史代码使其能在多任务环境中运行。
3. 明天创建真正的内核任务, 完善tcb链, 实现任务调度。

2016.07.02
1. 纠正昨天的错误，我任务一个任务只能使用固定的段(就是在
创建任务时填写在tss中的), 为了适应多任务, 在临时修改段选择器
的时候必须关中断, 以免从中断返回时使用tss指定的选择子加载段,
从而导致修改被破坏, 这是错误的, 实践证明,中断处理过程对寄存器的
保护与普通过程是一致的, 寄存器的值只能被人为修改(除了EFLAGS),
进入中断处理程序EFLAGS.ti会被固件清零以禁止嵌套的中断,
(陷阱可被中断中断), 使用tss恢复现场只发生在任务切换的时候,
(从中断返回只使用tss验证), 并且在发起任务切换时原任务段选择器
会被保护(我以为只保护通用寄存器和EFLAGS), 所以昨天调用外部例程
出现段错误的异常原因在别处,尽管我现在还不知道:)。
(2016.07.20: 外部调用不可重入)
2. 新增任务挂起, 任务结束状态, 以及实现。还没调试。
3. 还需一个监控进程, 定时清理挂起进程; 和进程计数(ok)。
4. 整理代码, 微调结构, 规范命名。

2016.07.03
1. 讲道理，今天休息一天。

2016.07.04 - 2016.07.16
1. ~

2016.07.17
1. TREE_TCB_STATUS_FIN。

2016.07.18
1. 测试多进程调度。
2. 重新对rtc芯片编程，更精确的实时时钟中断。
3. 解决销毁进程tss所用内存泄露的问题。

2016.07.19
1. TREE_TCB_STATUS_HUNG。
2. TREE_TCB_STATUS_FIN。
3. TREE_TCB_STATUS_SLEEP。
4. 改名共享存储区为静态存储区,对用户程序。
5. 使用自旋锁技术同步, 但还没有成功。

2016.07.20
1. 完成自旋锁。
2. 失败的原因是外部过程调用的实现无法重入，(已修复)
之前是使用关中断的方法同步，同时同步了外部过程调用的代码，
所以没有注意到。
3. 修复一个进程调度/休眠的虫子导致进程重入。
4. 新增进程计数，活动进程计数的概念。
5. 重构time.bin, 新增时间日期格式化例程。
6. 新增string.bin/strcpy。
7. 新增debug.s0, 包含一组0特权级下的调试工具。
8. 实时时钟更新。

2016.07.21
1. 封装调用门安装过程。
2. 规范化调用门调用。
3. 调整键盘驱动使运行。
4. 明天: kbd的虫子, 查询任务状态, 完善壳。
5. 新增: 子进程概念，壳挂起概念，多特权级任务(暂时不实现)。

2016.07.22
1. 关于键盘驱动程序的问题:
开机时前两次调用getchar0或gets读取到的值都是VK_NUM。
2. 这个结果只与验证虚拟机Oracle VirtualBox有关，在调试虚拟机
BOCHS上面运行时不会出现。
3. 具体表现是这样的：
如果物理机具有NumLock状态，VirtualBox会对虚拟机产生的
前两次键击进行处理。(还有CapsLock...)
4. 每次键击会控制键盘控制器产生两次中断请求，在前一次的
中断响应中处理程序读取到的扫描码是SCAN_NUMLOCK。
5. 它可能是想让虚拟机开机时就具有和物理机相同的键盘状态，但是
控制同样的状态按键按下两次, 其意义就不得而知了。
6. 由于getchar0和gets这两个例程的实现:
每次从键盘缓冲区新的读取都会先清空键盘缓冲区(这个做法现在看来
是不合理的的，这样一来键盘缓冲区就没有存在的必要了)。
因此无法处理一次按键产生了两次扫描码的情况，
读取了第一个字符后(状态码)，实际的输入反而在
第二次读取前被清除了。(gets中VK_NUM会结束输入)
7. 要解决这个问题: 避免在读取前清空输入缓冲区。
9. 同步大部分例程。
10. 控制台颜色系统。
11. 壳挂起，壳唤醒，壳绑定任务。
12. 完成多任务环境下的壳程序。

2016.07.23
1. 待办: GetTickCount()。(ok)
2. 待办: GetTaskPid()。(ok)
3. 待办: queue.bin linked-list.bin
array-list.bin stack.bin。 (ok)

2016.07.24
1. 考虑VESA图形显示技术。

2016.07.25
1. 待办: 动态库析构。

2016.07.26
1. 1280*720*8*双缓冲显示技术。
2. Texture->buf->Framebuf图形架构。
3. 待办: 控制台/图形模式动态切换, 切换色板。

2016.07.27
1. 今天，封装一些常用数据结构。
2. 安装了256色色板。

2016.07.28
1. 新增纹理，字渲染概念。

2016.07.29
1. 待办: 命令行参数结构, 使用栈传递。
2. 待办: 使用栈传递pid。(不再需要)
3. 纹理的支持: texture.bin。

2016.07.30
1. 文字的支持: font.bin。
2. 显示刷新线程, 叠加层。
3. 绘制桌面。
4. 绘制色板。

2016.07.31
1. 待办: 内存状态显示。
2. 绘制窗口并把昨天的色板放进去。
3. mouse.bin。
4. 优化texture.BlitTexture。
5. 绘制鼠标。
6. 问题: 按键导致异常(键盘)。
7. 解决: 中断是需要手动保护现场的。

2016.08.01
１. 接新文件
